"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecurityRepository = exports.SecurityResource = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const luxon_1 = require("luxon");
const httpConstants_1 = require("../integration/assets/httpConstants");
const BaseRepository_1 = require("./BaseRepository");
var SecurityResource;
(function (SecurityResource) {
    SecurityResource["SSO"] = "/security/sso";
    SecurityResource["TOKEN"] = "/security/token";
    SecurityResource["OTP"] = "/security/otp";
    SecurityResource["VALIDATE_OTP"] = "/security/otp/{code}/validate";
})(SecurityResource || (exports.SecurityResource = SecurityResource = {}));
class SecurityRepository extends BaseRepository_1.BaseRepository {
    props;
    constructor(props) {
        super(props);
        this.props = props;
    }
    async sendLambdaCommand(payload) {
        const invokeCommand = new client_lambda_1.InvokeCommand({
            FunctionName: this.props.securityLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify(payload)),
        });
        const response = await this.props.lambdaClient.send(invokeCommand);
        return this.processLambdaApiResponse(response);
    }
    async singleSignOn(externalId) {
        const payload = {
            resource: SecurityResource.SSO,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.getExternalHeaders(),
            body: JSON.stringify({
                employee: {
                    externalId,
                },
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async getExternalToken(code) {
        const payload = {
            resource: SecurityResource.TOKEN,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.getExternalHeaders(),
            body: JSON.stringify({
                code,
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async findOTPs(securityOTP) {
        try {
            const response = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
                TableName: this.props.securityOTPTable,
                KeyConditionExpression: "#customerId = :customerId",
                FilterExpression: "#status = :status AND #creationDate > :creationDate",
                ExpressionAttributeNames: {
                    "#customerId": "customerId",
                    "#status": "status",
                    "#creationDate": "creationDate",
                },
                ExpressionAttributeValues: {
                    ":customerId": securityOTP.customer?.id,
                    ":status": securityOTP.status,
                    ":creationDate": luxon_1.DateTime.now()
                        .setZone("America/Lima")
                        .set({ hour: 0, minute: 1, second: 0, millisecond: 0 })
                        .toMillis(),
                },
            }));
            return response.Items.map((item) => ({
                customer: {
                    id: item.customerId,
                },
                code: item.code,
                resource: item.resource,
                status: item.status,
                creationDate: item.creationDate,
                lastUpdateDate: item.lastUpdateDate,
            }));
        }
        catch (error) {
            throw error;
        }
    }
    async createOTP(securityOTP) {
        const payload = {
            resource: SecurityResource.OTP,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.getInternalHeaders({
                customerId: securityOTP.customer?.id,
                customerType: BaseRepository_1.CustomerType.INDIVIDUAL,
            }),
            body: JSON.stringify({
                resource: securityOTP.resource,
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async validateOTP(securityOTP) {
        const payload = {
            resource: SecurityResource.VALIDATE_OTP,
            httpMethod: httpConstants_1.HttpMethod.POST,
            pathParameters: {
                code: securityOTP.code,
            },
            headers: this.getInternalHeaders({
                customerId: securityOTP.customer?.id,
                customerType: BaseRepository_1.CustomerType.INDIVIDUAL,
            }),
        };
        return this.sendLambdaCommand(payload);
    }
}
exports.SecurityRepository = SecurityRepository;
//# sourceMappingURL=SecurityRepository.js.map