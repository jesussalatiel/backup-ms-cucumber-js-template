"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmployeesRepository = void 0;
const client_cognito_identity_provider_1 = require("@aws-sdk/client-cognito-identity-provider");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const client_lambda_1 = require("@aws-sdk/client-lambda");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const BaseRepository_1 = require("./BaseRepository");
const httpConstants_1 = require("../integration/assets/httpConstants");
const TRANSACTION_MAX_ITEMS = 100;
const MAX_PARALLEL_PROMISES = 20;
var EmployeeResource;
(function (EmployeeResource) {
    EmployeeResource["Employees"] = "/employees";
    EmployeeResource["EmployeesById"] = "/employees/{employeeId}";
})(EmployeeResource || (EmployeeResource = {}));
class EmployeesRepository extends BaseRepository_1.BaseRepository {
    props;
    constructor(props) {
        super(props);
        this.props = props;
    }
    getTimestamp() {
        return Date.now();
    }
    async sendLambdaCommand(payload) {
        const invokeCommand = new client_lambda_1.InvokeCommand({
            FunctionName: this.props.employeesLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify(payload)),
        });
        const response = await this.props.lambdaClient.send(invokeCommand);
        return this.processLambdaApiResponse(response);
    }
    async findById(employeeId) {
        const payload = {
            resource: EmployeeResource.EmployeesById,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { employeeId },
            headers: this.getBackOfficeHeaders(),
        };
        return this.sendLambdaCommand(payload);
    }
    async findByExternalId(externalId) {
        const payload = {
            resource: EmployeeResource.Employees,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                externalId,
            },
            headers: this.getBackOfficeHeaders(),
        };
        return this.sendLambdaCommand(payload);
    }
    async findEmployeeCognitoByExternalId(externalId) {
        const { Users: users } = await this.props.cognitoClient.send(new client_cognito_identity_provider_1.ListUsersCommand({
            UserPoolId: this.props.userPoolId,
            Filter: `preferred_username = "${externalId}"`,
        }));
        return !!users?.length;
    }
    async createEmployee(employee) {
        const payload = {
            resource: EmployeeResource.Employees,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.getBackOfficeHeaders(),
            body: JSON.stringify(employee),
        };
        return this.sendLambdaCommand(payload);
    }
    async updateEmployee(employee) {
        const payload = {
            resource: EmployeeResource.EmployeesById,
            httpMethod: httpConstants_1.HttpMethod.PATCH,
            pathParameters: { employeeId: employee.id },
            headers: this.getBackOfficeHeaders(),
            body: JSON.stringify(employee),
        };
        return this.sendLambdaCommand(payload);
    }
    async deleteById(employeeId) {
        const payload = {
            resource: EmployeeResource.EmployeesById,
            httpMethod: httpConstants_1.HttpMethod.DELETE,
            pathParameters: { employeeId },
            headers: this.getBackOfficeHeaders(),
        };
        return this.sendLambdaCommand(payload);
    }
    async createMasiveEmployees(employees) {
        try {
            const result = await this.createEmployeesCognito(employees);
            const employeesLength = await this.createEmployeesDynamo(result);
            return employeesLength;
        }
        catch (e) {
            throw new Error(e.message);
        }
    }
    async initiateAuth(username, password) {
        const result = await this.props.cognitoClient.send(new client_cognito_identity_provider_1.InitiateAuthCommand({
            ClientId: this.props.applications.backOffice,
            AuthFlow: "USER_PASSWORD_AUTH",
            AuthParameters: {
                USERNAME: username,
                PASSWORD: password,
            },
        }));
        const token = result.AuthenticationResult?.IdToken;
        return { token };
    }
    async changePassword(username, password) {
        await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminSetUserPasswordCommand({
            UserPoolId: this.props.userPoolId,
            Username: username,
            Password: password,
            Permanent: true,
        }));
    }
    async createEmployeesCognito(employees) {
        try {
            const newEmployees = [];
            await Promise.all(employees.map(async (employee) => {
                const params = {
                    UserPoolId: this.props.userPoolId,
                    Username: employee.externalId,
                    UserAttributes: [
                        {
                            Name: "given_name",
                            Value: employee.name,
                        },
                        {
                            Name: "middle_name",
                            Value: employee.middleName,
                        },
                        {
                            Name: "family_name",
                            Value: employee.lastName,
                        },
                        {
                            Name: "preferred_username",
                            Value: employee.externalId,
                        },
                        {
                            Name: "custom:role",
                            Value: employee.role,
                        },
                    ],
                };
                const existEmployee = await this.findEmployeeCognitoByExternalId(employee.externalId);
                if (!existEmployee) {
                    const result = await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminCreateUserCommand(params));
                    const password = this.createPassword(employee.externalId);
                    await this.changePassword(result.User?.Username, password);
                    newEmployees.push({
                        id: result.User?.Username,
                        ...employee,
                    });
                }
            }));
            return newEmployees;
        }
        catch (e) {
            throw new Error(e.message);
        }
    }
    async createEmployeesDynamo(employees) {
        const timestamp = this.getTimestamp();
        const commandListDynamo = [];
        for (let i = 0; i < employees.length; i += TRANSACTION_MAX_ITEMS) {
            commandListDynamo.push(this.props.dynamoDbClient.send(new lib_dynamodb_1.TransactWriteCommand({
                TransactItems: employees
                    .slice(i, i + TRANSACTION_MAX_ITEMS)
                    .map((item) => ({
                    Put: {
                        TableName: this.props.employeesTable,
                        Item: {
                            id: item.id,
                            motherLastName: item.motherLastName,
                            company: item.company,
                            creationDate: timestamp,
                        },
                    },
                })),
            })));
        }
        for (let i = 0; i < commandListDynamo.length; i += MAX_PARALLEL_PROMISES) {
            // eslint-disable-next-line no-await-in-loop
            await Promise.allSettled(commandListDynamo.slice(i, i + MAX_PARALLEL_PROMISES));
        }
        return employees.length;
    }
    createPassword(externalID) {
        return `${externalID}${this.props.employeesSalt}`;
    }
}
exports.EmployeesRepository = EmployeesRepository;
//# sourceMappingURL=EmployeesRepository.js.map