"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractsRepository = exports.ContractResource = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const BaseRepository_1 = require("./BaseRepository");
const httpConstants_1 = require("../integration/assets/httpConstants");
var ContractResource;
(function (ContractResource) {
    ContractResource["Contracts"] = "/contracts";
    ContractResource["ContractById"] = "/contracts/{contractId}";
})(ContractResource || (exports.ContractResource = ContractResource = {}));
class ContractsRepository extends BaseRepository_1.BaseRepository {
    props;
    constructor(props) {
        super(props);
        this.props = props;
    }
    async sendLambdaCommand(payload) {
        const invokeCommand = new client_lambda_1.InvokeCommand({
            FunctionName: this.props.contractsLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify(payload)),
        });
        const response = await this.props.lambdaClient.send(invokeCommand);
        return this.processLambdaApiResponse(response);
    }
    async findById(customerId, contractId) {
        const payload = {
            resource: ContractResource.ContractById,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { contractId },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: customerId,
                },
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async createContract(contract) {
        const payload = {
            resource: ContractResource.Contracts,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: contract.customer.id,
                },
            }),
            body: JSON.stringify(contract),
        };
        return this.sendLambdaCommand(payload);
    }
    async downloadByLoanId(props) {
        const payload = {
            resource: ContractResource.Contracts,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                loanId: props.loan.id,
                extended: props.extended,
            },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: props.customer.id,
                },
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async updateStatusSigned(contract) {
        const payload = {
            resource: ContractResource.ContractById,
            httpMethod: httpConstants_1.HttpMethod.PATCH,
            pathParameters: { contractId: contract.id },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: contract.customer.id,
                },
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async findByCustomerId(customerId) {
        const { Items: items } = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
            TableName: this.props.contractsTable,
            KeyConditionExpression: "#customerId = :customerId",
            ExpressionAttributeNames: {
                "#customerId": "customerId",
            },
            ExpressionAttributeValues: {
                ":customerId": customerId,
            },
        }));
        if (!items.length) {
            throw new Error("Contracts not found");
        }
        return items;
    }
    async deleteByCustomerId(customerId) {
        const result = await this.findByCustomerId(customerId);
        await Promise.all(result.map(async (item) => {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
                TableName: this.props.contractsTable,
                Key: { id: item.id, customerId },
            }));
        }));
    }
}
exports.ContractsRepository = ContractsRepository;
//# sourceMappingURL=ContractsRepository.js.map