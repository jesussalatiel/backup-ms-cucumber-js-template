"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoansRepository = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const BaseRepository_1 = require("./BaseRepository");
const httpConstants_1 = require("../integration/assets/httpConstants");
var LoanResource;
(function (LoanResource) {
    LoanResource["InstallmentsByIdentityDocument"] = "/installments";
    LoanResource["Loans"] = "/loans";
    LoanResource["LoanById"] = "/loans/{loanId}";
    LoanResource["Installments"] = "/loans/{loanId}/installments";
    LoanResource["Transactions"] = "/loans/{loanId}/transactions";
    LoanResource["Notifications"] = "/loans/{loanId}/transactions-notifications";
    LoanResource["InstallmentById"] = "/loans/{loanId}/installments/{installmentId}";
    LoanResource["Simulations"] = "/simulations";
    LoanResource["SimulationsById"] = "/simulations/{simulationId}";
    LoanResource["Reconciliations"] = "/reconciliations";
    LoanResource["PreviewPayOff"] = "/loans/{loanId}/previewPayoff";
    LoanResource["TransactionById"] = "/loans/{loanId}/transactions/{transactionId}";
})(LoanResource || (LoanResource = {}));
class LoansRepository extends BaseRepository_1.BaseRepository {
    props;
    constructor(props) {
        super(props);
        this.props = props;
    }
    async sendLambdaRequest(payload) {
        const invokeCommand = new client_lambda_1.InvokeCommand({
            FunctionName: this.props.loansLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify(payload)),
        });
        const response = await this.props.lambdaClient.send(invokeCommand);
        return this.processLambdaApiResponse(response);
    }
    async findByCustomerId(customerId, withPendingInstallments) {
        const payload = {
            resource: LoanResource.Loans,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: withPendingInstallments
                ? { withPendingInstallments: "true" }
                : undefined,
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: customerId,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async findByDate(startDate, endDate) {
        const payload = {
            resource: LoanResource.Loans,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                startDate,
                endDate,
            },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async findById(loan) {
        const payload = {
            resource: LoanResource.LoanById,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { loanId: loan.id },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: loan.customer.id,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async findInstallments(loanId, customerId) {
        const payload = {
            resource: LoanResource.Installments,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { loanId },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: customerId,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async findSimulationById(simulationId) {
        const payload = {
            resource: LoanResource.SimulationsById,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { simulationId },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Internal,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async createLoan(loan) {
        const payload = {
            resource: LoanResource.Loans,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: loan.customer.id,
                },
            }),
            body: JSON.stringify(loan),
        };
        return this.sendLambdaRequest(payload);
    }
    async createSimulation(props) {
        // TODO: use ISimulation instead of loan object
        const payload = {
            resource: LoanResource.Simulations,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: props.customerId,
                },
            }),
            body: JSON.stringify(props.loan),
        };
        return this.sendLambdaRequest(payload);
    }
    async createTransaction(transaction, loanId) {
        const payload = {
            resource: LoanResource.Transactions,
            httpMethod: httpConstants_1.HttpMethod.POST,
            pathParameters: { loanId },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
            body: JSON.stringify(transaction),
        };
        return this.sendLambdaRequest(payload);
    }
    async createTransactionNotification(transaction) {
        const payload = {
            resource: LoanResource.Notifications,
            httpMethod: httpConstants_1.HttpMethod.POST,
            pathParameters: { loanId: transaction.loan.id },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: transaction.customer.id,
                },
            }),
            body: JSON.stringify(transaction),
        };
        return this.sendLambdaRequest(payload);
    }
    async findInstallmentByIndentity(loan) {
        const payload = {
            resource: LoanResource.InstallmentsByIdentityDocument,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                documentType: loan.customer.identityDocument.type,
                documentNumber: loan.customer.identityDocument.number,
            },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async deleteTransaction(loan) {
        const payload = {
            resource: LoanResource.TransactionById,
            httpMethod: httpConstants_1.HttpMethod.DELETE,
            pathParameters: { loanId: loan.id, transactionId: loan.transaction.id },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async delete(props) {
        const payload = {
            resource: LoanResource.LoanById,
            httpMethod: httpConstants_1.HttpMethod.DELETE,
            pathParameters: { loanId: props.loan.id },
            queryStringParameters: {
                customerId: props.customer.id,
            },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async reconciliations(props) {
        const payload = {
            resource: LoanResource.Reconciliations,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
            body: JSON.stringify(props),
        };
        return this.sendLambdaRequest(payload);
    }
    async update(props) {
        const payload = {
            resource: LoanResource.LoanById,
            httpMethod: httpConstants_1.HttpMethod.PATCH,
            pathParameters: { loanId: props.loanId },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: props.customerId,
                },
            }),
            body: JSON.stringify(props.body),
        };
        return this.sendLambdaRequest(payload);
    }
    async findAccountingItem(loanId) {
        try {
            const { Items } = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
                TableName: this.props.accountingTable,
                KeyConditionExpression: "#loanId = :loanId",
                ExpressionAttributeNames: {
                    "#loanId": "loanId",
                },
                ExpressionAttributeValues: {
                    ":loanId": loanId,
                },
            }));
            return Items;
        }
        catch (error) {
            return [];
        }
    }
    async activateLoan(props) {
        const payload = {
            resource: LoanResource.LoanById,
            httpMethod: httpConstants_1.HttpMethod.PATCH,
            pathParameters: { loanId: props.loan.id },
            body: JSON.stringify({
                id: props.loan.id,
                customer: {
                    id: props.loan.customer.id,
                },
                status: props.activateLoan ? "ACTIVE" : undefined,
            }),
            headers: this.selectHeaderType({
                header: {
                    type: props.headerType,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async findPreviewPayOff(loanId, customerId) {
        const payload = {
            resource: LoanResource.PreviewPayOff,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { loanId },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.Individual,
                },
                customer: {
                    id: customerId,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async searchCreditWithIBK(documentType, documentNumber) {
        const payload = {
            resource: LoanResource.Loans,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                documentType,
                documentNumber,
            },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async createPaymentWithIBK(props) {
        const payload = {
            resource: LoanResource.Transactions,
            body: JSON.stringify({
                customer: {
                    id: props.customer.id,
                },
                installments: props.installments,
                amount: props.amount,
                currency: props.currency,
                prepaymentMethod: props.prepaymentMethod,
            }),
            httpMethod: httpConstants_1.HttpMethod.POST,
            pathParameters: { loanId: props.loan.id },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async cancelPaymentWithIBK(loanId, transactionId) {
        const payload = {
            resource: LoanResource.TransactionById,
            httpMethod: httpConstants_1.HttpMethod.DELETE,
            pathParameters: {
                loanId,
                transactionId,
            },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
        };
        return this.sendLambdaRequest(payload);
    }
    async transactionReturnWithIBK(props) {
        const payload = {
            resource: LoanResource.Notifications,
            httpMethod: httpConstants_1.HttpMethod.POST,
            pathParameters: { loanId: props.loan.id },
            headers: this.selectHeaderType({
                header: {
                    type: httpConstants_1.HeaderType.External,
                },
            }),
            body: JSON.stringify(props.body),
        };
        return this.sendLambdaRequest(payload);
    }
    async updateAttribute(loanId, customerId, attributeName, attributeValue) {
        try {
            if (!attributeValue) {
                await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                    TableName: this.props.loansTable,
                    Key: { id: loanId, customerId },
                    ConditionExpression: "attribute_exists(id)",
                    UpdateExpression: `REMOVE ${attributeName}`,
                }));
            }
            else {
                await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                    TableName: this.props.loansTable,
                    Key: { id: loanId, customerId },
                    ConditionExpression: "attribute_exists(id)",
                    UpdateExpression: "SET #key = :value",
                    ExpressionAttributeNames: { "#key": attributeName },
                    ExpressionAttributeValues: { ":value": attributeValue },
                }));
            }
            return true;
        }
        catch (error) {
            throw new Error(error);
        }
    }
    async updateAttributes(loan) {
        try {
            const updateExpression = this.getUpdateExpression(loan, [
                "amount",
                "term",
                "interestRate",
                "annualNominalRate",
                "status",
                "creationDate",
                "lastUpdateDate",
                "activationDate",
                "lastMambuUpdateDate",
            ]);
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: this.props.loansTable,
                Key: { id: loan.id, customerId: loan.customer.id },
                ConditionExpression: "attribute_exists(id)",
                ...updateExpression,
            }));
        }
        catch (error) {
            throw new Error(error);
        }
    }
    async deleteById(loanId, customerId) {
        await this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
            TableName: this.props.loansTable,
            Key: { id: loanId, customerId },
        }));
    }
    async deleteByCustomerId(customerId) {
        const result = await this.findByCustomerId(customerId);
        if (Object.keys(result.body).length === 0) {
            throw new Error("Nothing to delete");
        }
        await Promise.all(result.body.map(async (item) => {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
                TableName: this.props.loansTable,
                Key: { id: item.id, customerId },
            }));
        }));
    }
    async updateInstallment(installment) {
        try {
            const updateExpression = this.getUpdateExpression(installment, [
                "status",
                "dueDate",
                "principalDue",
                "interestDue",
                "feeDue",
                "penaltyDue",
                "totalDue",
                "creationDate",
                "lastUpdateDate",
            ]);
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: this.props.loansInstallmentsTable,
                Key: { id: installment.id, loanId: installment.loan.id },
                ConditionExpression: "attribute_exists(id)",
                ...updateExpression,
            }));
        }
        catch (error) {
            throw new Error(error);
        }
    }
}
exports.LoansRepository = LoansRepository;
//# sourceMappingURL=LoansRepository.js.map