"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseRepository = exports.CustomerType = exports.ApplicationType = exports.AUTHORIZATION = exports.EMPLOYEE_ID_HEADER = exports.CUSTOMER_TYPE_HEADER = exports.CUSTOMER_ID_HEADER = exports.APPLICATION_TYPE_HEADER = exports.APPLICATION_ID_HEADER = exports.CORRELATION_HEADER = void 0;
const crypto_1 = require("crypto");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const httpConstants_1 = require("../integration/assets/httpConstants");
exports.CORRELATION_HEADER = "IHF-Correlation-Id";
exports.APPLICATION_ID_HEADER = "IHF-Application-Id";
exports.APPLICATION_TYPE_HEADER = "IHF-Application-Type";
exports.CUSTOMER_ID_HEADER = "IHF-Customer-Id";
exports.CUSTOMER_TYPE_HEADER = "IHF-Customer-Type";
exports.EMPLOYEE_ID_HEADER = "IHF-Employee-Id";
exports.AUTHORIZATION = "Authorization";
var ApplicationType;
(function (ApplicationType) {
    ApplicationType["CUSTOMER"] = "CUSTOMER";
    ApplicationType["EMPLOYEE"] = "EMPLOYEE";
    ApplicationType["EXTERNAL"] = "EXTERNAL";
    ApplicationType["INTERNAL"] = "INTERNAL";
})(ApplicationType || (exports.ApplicationType = ApplicationType = {}));
var CustomerType;
(function (CustomerType) {
    CustomerType["INDIVIDUAL"] = "INDIVIDUAL";
    CustomerType["BUSINESS"] = "BUSINESS";
})(CustomerType || (exports.CustomerType = CustomerType = {}));
class BaseRepository {
    props;
    constructor(props) {
        this.props = props;
    }
    getUuid() {
        return `${(0, crypto_1.randomUUID)()}`;
    }
    getUpdateExpression(domain, attributes) {
        const attrToUpdate = attributes.filter((key) => domain[key] !== undefined);
        if (attrToUpdate.length === 0) {
            return undefined;
        }
        return attrToUpdate.reduce((prev, curr, index) => {
            const key = String(curr);
            return {
                UpdateExpression: `${prev.UpdateExpression}${index === 0 ? "" : ","} #${key} = :${key}`,
                ExpressionAttributeNames: {
                    ...prev.ExpressionAttributeNames,
                    [`#${key}`]: curr,
                },
                ExpressionAttributeValues: {
                    ...prev.ExpressionAttributeValues,
                    [`:${key}`]: domain[curr],
                },
            };
        }, {
            UpdateExpression: "SET",
            ExpressionAttributeNames: {},
            ExpressionAttributeValues: {},
        });
    }
    getInternetBankingHeaders(params) {
        return {
            [exports.APPLICATION_ID_HEADER]: this.props.applications.internetBanking,
            [exports.APPLICATION_TYPE_HEADER]: ApplicationType.CUSTOMER,
            [exports.CORRELATION_HEADER]: this.getUuid(),
            [exports.CUSTOMER_ID_HEADER]: params.customerId,
            [exports.CUSTOMER_TYPE_HEADER]: CustomerType.INDIVIDUAL,
            [exports.EMPLOYEE_ID_HEADER]: undefined,
        };
    }
    getExternalHeaders() {
        return {
            [exports.APPLICATION_ID_HEADER]: this.props.applications.internetBanking,
            [exports.APPLICATION_TYPE_HEADER]: ApplicationType.EXTERNAL,
            [exports.CORRELATION_HEADER]: this.getUuid(),
            [exports.CUSTOMER_ID_HEADER]: undefined,
            [exports.CUSTOMER_TYPE_HEADER]: CustomerType.BUSINESS,
            [exports.EMPLOYEE_ID_HEADER]: undefined,
        };
    }
    getBackOfficeHeaders() {
        return {
            [exports.APPLICATION_ID_HEADER]: this.props.applications.backOffice,
            [exports.APPLICATION_TYPE_HEADER]: ApplicationType.EMPLOYEE,
            [exports.CORRELATION_HEADER]: this.getUuid(),
            [exports.CUSTOMER_ID_HEADER]: undefined,
            [exports.CUSTOMER_TYPE_HEADER]: undefined,
            [exports.EMPLOYEE_ID_HEADER]: this.props.employeeId,
        };
    }
    getInternalHeaders(params) {
        return {
            [exports.APPLICATION_ID_HEADER]: "QA",
            [exports.APPLICATION_TYPE_HEADER]: ApplicationType.INTERNAL,
            [exports.CORRELATION_HEADER]: this.getUuid(),
            [exports.CUSTOMER_ID_HEADER]: params.customerId,
            [exports.CUSTOMER_TYPE_HEADER]: params.customerType,
            [exports.EMPLOYEE_ID_HEADER]: undefined,
        };
    }
    getInternetBankingRequestContext(params) {
        return {
            authorizer: {
                claims: {
                    aud: this.props.applications.internetBanking,
                    sub: params.customerId,
                    "custom:documentType": params.documentType,
                    "custom:documentNumber": params.documentNumber,
                },
            },
        };
    }
    validateLambdaResponse(lambdaResponse, expect) {
        if (lambdaResponse.StatusCode !== expect.statusCode) {
            throw new Error(`[Lambda] StatusCode: ${lambdaResponse.StatusCode}`);
        }
        if (expect.payload && !lambdaResponse.Payload) {
            throw new Error(`[Lambda] Payload: ${lambdaResponse.Payload}`);
        }
    }
    processLambdaApiResponse(lambdaResponse) {
        this.validateLambdaResponse(lambdaResponse, {
            statusCode: 200,
            payload: true,
        });
        let payload;
        if (lambdaResponse.Payload) {
            payload = JSON.parse((0, util_utf8_1.toUtf8)(lambdaResponse.Payload));
        }
        return {
            ...payload,
            body: payload.body ? JSON.parse(payload.body) : undefined,
        };
    }
    selectHeaderType(props) {
        switch (props.header.type) {
            case httpConstants_1.HeaderType.Employee:
                return { ...this.getBackOfficeHeaders() };
            case httpConstants_1.HeaderType.Individual:
                return {
                    ...this.getInternetBankingHeaders({ customerId: props.customer.id }),
                };
            case httpConstants_1.HeaderType.External:
                return { ...this.getExternalHeaders() };
            case httpConstants_1.HeaderType.Internal:
                return {
                    ...this.getInternalHeaders({
                        customerId: props.customer?.id,
                    }),
                };
            default:
                throw new Error("Header type is not supported.");
        }
    }
}
exports.BaseRepository = BaseRepository;
//# sourceMappingURL=BaseRepository.js.map