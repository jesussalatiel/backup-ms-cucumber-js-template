"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomersRepository = exports.CustomerResource = void 0;
const promises_1 = require("node:fs/promises");
const client_lambda_1 = require("@aws-sdk/client-lambda");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const client_cognito_identity_provider_1 = require("@aws-sdk/client-cognito-identity-provider");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const csvtojson_1 = __importDefault(require("csvtojson"));
const axios_1 = __importDefault(require("axios"));
const httpConstants_1 = require("../integration/assets/httpConstants");
const CognitoRepository_1 = require("./CognitoRepository");
const TRANSACTION_MAX_ITEMS = 100;
const DOCUMENT_KEY_INDEX = "documentKeyIndex";
var CustomerResource;
(function (CustomerResource) {
    CustomerResource["CustomerById"] = "/customers/{customerId}";
    CustomerResource["Customers"] = "/customers";
})(CustomerResource || (exports.CustomerResource = CustomerResource = {}));
class CustomersRepository extends CognitoRepository_1.CognitoRepository {
    props;
    constructor(props) {
        super(props);
        this.props = props;
    }
    getTimestamp() {
        return Date.now();
    }
    async sendLambdaCommand(payload) {
        const invokeCommand = new client_lambda_1.InvokeCommand({
            FunctionName: this.props.customersLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify(payload)),
        });
        const response = await this.props.lambdaClient.send(invokeCommand);
        return this.processLambdaApiResponse(response);
    }
    async invokeWarmUp() {
        try {
            const invokeCommand = new client_lambda_1.InvokeCommand({
                FunctionName: this.props.customersLambda,
                InvocationType: "Event",
                Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify({})),
            });
            await this.props.lambdaClient.send(invokeCommand);
            return true;
        }
        catch (error) {
            throw new Error(error);
        }
    }
    findById(customerId, params) {
        const payload = {
            resource: CustomerResource.CustomerById,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { customerId },
            queryStringParameters: {
                extended: params?.extended ? "true" : undefined,
            },
            headers: this.getInternetBankingHeaders({
                customerId,
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async findByIdentityDocument(identityType, identityNumber) {
        const payload = {
            resource: CustomerResource.Customers,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                type: identityType,
                number: identityNumber,
            },
            headers: this.getBackOfficeHeaders(),
        };
        return this.sendLambdaCommand(payload);
    }
    async find(endPoint) {
        const payload = {
            resource: endPoint,
            httpMethod: httpConstants_1.HttpMethod.GET,
        };
        return this.sendLambdaCommand(payload);
    }
    async webHook(path, customerId) {
        const payload = {
            resource: `/webhooks/${path}`,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.getBackOfficeHeaders(),
            requestContext: {
                authorizer: { claims: { sub: customerId } },
            },
        };
        return this.sendLambdaCommand(payload);
    }
    async createCustomer(customer) {
        const payload = {
            resource: CustomerResource.Customers,
            httpMethod: httpConstants_1.HttpMethod.POST,
            headers: this.getBackOfficeHeaders(),
            body: JSON.stringify(customer),
        };
        return this.sendLambdaCommand(payload);
    }
    async createMasiveCustomersReniec(customers) {
        const timestamp = this.getTimestamp();
        for (let i = 0; i < customers.length; i += TRANSACTION_MAX_ITEMS) {
            // eslint-disable-next-line no-await-in-loop
            await new Promise((res) => {
                setTimeout(res, 100);
            });
            // eslint-disable-next-line no-await-in-loop
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.TransactWriteCommand({
                TransactItems: customers
                    .slice(i, i + TRANSACTION_MAX_ITEMS)
                    .map((item) => ({
                    Put: {
                        TableName: this.props.customersReniecTable,
                        Item: {
                            id: this.getUuid(),
                            documentKey: `${item.identityDocument.type}${item.identityDocument.number}`,
                            name: item.name,
                            middleName: item.middleName.length > 0 ? item.middleName : undefined,
                            lastName: item.lastName,
                            motherLastName: item.motherLastName,
                            creationDate: timestamp,
                        },
                    },
                })),
            }));
        }
        return customers.length;
    }
    async searchReniecCustomer(identityType, identityNumber) {
        return this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
            TableName: this.props.customersReniecTable,
            IndexName: DOCUMENT_KEY_INDEX,
            KeyConditionExpression: "#documentKey = :documentKey",
            ExpressionAttributeNames: {
                "#documentKey": "documentKey",
            },
            ExpressionAttributeValues: {
                ":documentKey": `${identityType}${identityNumber}`,
            },
        }));
    }
    async update(customerId, body, isIndividual = true) {
        const payload = {
            resource: CustomerResource.CustomerById,
            httpMethod: httpConstants_1.HttpMethod.PATCH,
            pathParameters: { customerId },
            headers: isIndividual
                ? this.selectHeaderType({
                    header: {
                        type: httpConstants_1.HeaderType.Individual,
                    },
                    customer: {
                        id: customerId,
                    },
                })
                : this.getBackOfficeHeaders(),
            body: JSON.stringify(body),
        };
        return this.sendLambdaCommand(payload);
    }
    async sendInvitation(customerId, body) {
        const payload = {
            resource: CustomerResource.CustomerById,
            httpMethod: httpConstants_1.HttpMethod.PATCH,
            pathParameters: { customerId },
            headers: this.getBackOfficeHeaders(),
            body: JSON.stringify(body),
        };
        return this.sendLambdaCommand(payload);
    }
    async findByMobile(mobile) {
        const { Username } = await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminGetUserCommand({
            Username: mobile,
            UserPoolId: this.props.userPoolId,
        }));
        if (!Username) {
            throw new Error("User not found");
        }
        return this.findById(Username);
    }
    async updateAttribute(customerId, attributeName, attributeValue) {
        if (!attributeValue) {
            await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminDeleteUserAttributesCommand({
                Username: customerId,
                UserPoolId: this.props.userPoolId,
                UserAttributeNames: [attributeName],
            }));
        }
        else {
            await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminUpdateUserAttributesCommand({
                Username: customerId,
                UserPoolId: this.props.userPoolId,
                UserAttributes: [{ Name: attributeName, Value: attributeValue }],
            }));
        }
    }
    async updateStatusAndNextAction(customer) {
        await this.updateAttribute(customer.id, "custom:status", customer.status);
    }
    async updateAttributeDynamo(customerId, attributeName, attributeValue) {
        if (!attributeValue) {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: this.props.customersTable,
                Key: { id: customerId },
                ConditionExpression: "attribute_exists(id)",
                UpdateExpression: `REMOVE ${attributeName}`,
            }));
        }
        else {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: this.props.customersTable,
                Key: { id: customerId },
                ConditionExpression: "attribute_exists(id)",
                UpdateExpression: "SET #key = :value",
                ExpressionAttributeNames: { "#key": attributeName },
                ExpressionAttributeValues: { ":value": attributeValue },
            }));
        }
    }
    async updateDocumentKeyValidated(customerId, action) {
        switch (action) {
            case "validate": {
                await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminAddUserToGroupCommand({
                    GroupName: this.props.groupName,
                    UserPoolId: this.props.userPoolId,
                    Username: customerId,
                }));
                await this.updateAttributeDynamo(customerId, "documentKeyValidated", true);
                break;
            }
            case "invalidate": {
                await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminRemoveUserFromGroupCommand({
                    GroupName: this.props.groupName,
                    UserPoolId: this.props.userPoolId,
                    Username: customerId,
                }));
                await this.updateAttributeDynamo(customerId, "documentKeyValidated");
                break;
            }
            default:
                break;
        }
    }
    async updateMobile(customer) {
        if (!customer.mobile || !customer.id) {
            throw new Error("Invalid parameters");
        }
        await this.updateAttribute(customer.id, "phone_number", customer.mobile);
        await this.updateAttribute(customer.id, "phone_number_verified", "true");
    }
    async deleteById(customerId) {
        const customer = await this.findById(customerId);
        if (!customer) {
            throw new Error("User not found");
        }
        const errors = [];
        try {
            await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminDeleteUserCommand({
                Username: customerId,
                UserPoolId: this.props.userPoolId,
            }));
        }
        catch (e) {
            errors.push(e.message);
        }
        try {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
                TableName: this.props.customersTable,
                Key: { id: customerId },
            }));
        }
        catch (e) {
            errors.push(e.message);
        }
        if (errors.length) {
            throw new Error(errors.join(" | "));
        }
    }
    async deleteByMobile(mobile) {
        const customerId = await this.findCustomerIdByMobile(mobile);
        if (!customerId) {
            throw new Error("User not found");
        }
        const deleteUserPromise = this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminDeleteUserCommand({
            Username: customerId,
            UserPoolId: this.props.userPoolId,
        }));
        const deleteDynamoDBPromise = this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
            TableName: this.props.customersTable,
            Key: { id: customerId },
        }));
        try {
            await Promise.all([deleteUserPromise, deleteDynamoDBPromise]);
        }
        catch (errors) {
            const errorMessages = errors.map((e) => e.message);
            throw new Error(errorMessages.join(" | "));
        }
    }
    async deleteByIdentityDocument(type, number) {
        const { Items: items } = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
            TableName: this.props.customersTable,
            IndexName: DOCUMENT_KEY_INDEX,
            KeyConditionExpression: "#documentKey = :documentKey",
            ExpressionAttributeNames: {
                "#documentKey": "documentKey",
            },
            ExpressionAttributeValues: {
                ":documentKey": `${type}${number}`,
            },
        }));
        if (!items.length) {
            throw new Error("Nothing to delete");
        }
        await Promise.all(items
            .map((item) => item.id)
            .map(async (customerId) => {
            try {
                await this.props.cognitoClient.send(new client_cognito_identity_provider_1.AdminDeleteUserCommand({
                    Username: customerId,
                    UserPoolId: this.props.userPoolId,
                }));
            }
            catch (e) {
                /* empty */
            }
            try {
                await this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
                    TableName: this.props.customersTable,
                    Key: { id: customerId },
                }));
            }
            catch (e) {
                /* empty */
            }
        }));
    }
    async preSignUpTrigger(customer) {
        const response = await this.props.lambdaClient.send(new client_lambda_1.InvokeCommand({
            FunctionName: this.props.customersLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify({
                triggerSource: "PreSignUp_SignUp",
                request: {
                    userAttributes: {
                        email: customer.email,
                        phone_number: customer.mobile,
                        "custom:documentType": customer.identityDocument.type,
                        "custom:documentNumber": customer.identityDocument.number,
                    },
                },
            })),
        }));
        return this.processLambdaApiResponse(response);
    }
    convertToJson(data) {
        const jsonData = {};
        data.forEach((row) => {
            if (!(row.departamento in jsonData))
                jsonData[row.departamento] = {};
            if (!(row.provincia in jsonData[row.departamento]))
                jsonData[row.departamento][row.provincia] = [];
            jsonData[row.departamento][row.provincia].push(row.distrito);
        });
        return JSON.stringify(jsonData);
    }
    async generateLocationDataset(config) {
        let jsonData;
        switch (config.datasetSource) {
            case "file": {
                jsonData = await (0, csvtojson_1.default)().fromFile(config.inputFile);
                break;
            }
            default: {
                jsonData = await (0, csvtojson_1.default)().fromStream((await axios_1.default.get("https://cloud.minsa.gob.pe/s/GkfcJD8xKHJeCqn/download", {
                    responseType: "stream",
                })).data);
                break;
            }
        }
        await (0, promises_1.writeFile)(config.outputFile, this.convertToJson(jsonData));
    }
    async findAccountingItem(customerId) {
        try {
            const { Items } = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
                TableName: this.props.accountingTable,
                KeyConditionExpression: "#customerId = :customerId",
                ExpressionAttributeNames: {
                    "#customerId": "customerId",
                },
                ExpressionAttributeValues: {
                    ":customerId": customerId,
                },
            }));
            return Items;
        }
        catch (error) {
            return [];
        }
    }
    async findCustomerIdByMobile(mobile) {
        const [customerCognito] = (await this.props.cognitoClient.send(new client_cognito_identity_provider_1.ListUsersCommand({
            UserPoolId: this.props.userPoolId,
            Filter: `phone_number = "${mobile}"`,
        }))).Users;
        if (!customerCognito) {
            return undefined;
        }
        return customerCognito.Username;
    }
}
exports.CustomersRepository = CustomersRepository;
//# sourceMappingURL=CustomersRepository.js.map