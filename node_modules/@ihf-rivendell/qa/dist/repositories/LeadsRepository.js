"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeadsRepository = exports.LeadsResource = void 0;
const client_lambda_1 = require("@aws-sdk/client-lambda");
const client_secrets_manager_1 = require("@aws-sdk/client-secrets-manager");
const util_utf8_1 = require("@aws-sdk/util-utf8");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const BaseRepository_1 = require("./BaseRepository");
const httpConstants_1 = require("../integration/assets/httpConstants");
const index_1 = require("../utils/log/index");
var LeadsResource;
(function (LeadsResource) {
    LeadsResource["Leads"] = "/leads";
    LeadsResource["LeadById"] = "/leads/{leadId}";
    LeadsResource["LeadSales"] = "/leads/{leadId}/sales";
})(LeadsResource || (exports.LeadsResource = LeadsResource = {}));
class LeadsRepository extends BaseRepository_1.BaseRepository {
    props;
    secretsManagerClient;
    constructor(props) {
        super(props);
        this.props = props;
        this.secretsManagerClient = new client_secrets_manager_1.SecretsManagerClient({});
    }
    async getSecretValue() {
        try {
            const secretValue = await this.secretsManagerClient.send(new client_secrets_manager_1.GetSecretValueCommand({
                SecretId: this.props.secretId,
            }));
            const parsed = JSON.parse(secretValue.SecretString);
            return {
                ips: parsed.ips.split(",").map((ip) => ip.trim()),
            };
        }
        catch (error) {
            index_1.logger.info(error);
            throw new Error("Error getting secret value");
        }
    }
    async setSecretValue(values) {
        const request = JSON.stringify({
            ...values,
            ips: values.ips.join(","),
        });
        try {
            await this.secretsManagerClient.send(new client_secrets_manager_1.UpdateSecretCommand({
                SecretId: this.props.secretId,
                SecretString: request,
            }));
        }
        catch (error) {
            index_1.logger.info(error);
            throw new Error("Error updating secret value");
        }
    }
    async sendLambdaCommand(payload) {
        const invokeCommand = new client_lambda_1.InvokeCommand({
            FunctionName: this.props.leadsLambda,
            Payload: (0, util_utf8_1.fromUtf8)(JSON.stringify(payload)),
        });
        const response = await this.props.lambdaClient.send(invokeCommand);
        return this.processLambdaApiResponse(response);
    }
    async findByIdentityDocument(props) {
        const payload = {
            resource: LeadsResource.Leads,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                documentType: props.lead.customer.identityDocument.type,
                documentNumber: props.lead.customer.identityDocument.number,
                currency: props.lead.currency,
                amount: props.lead.amount,
                status: props.isActive ? "ACTIVE" : "INACTIVE",
                annualNominalRate: props.lead.annualNominalRate,
            },
            headers: this.selectHeaderType({
                header: {
                    type: props.headerType,
                },
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async findByCustomerId(lead, isActive) {
        const payload = {
            resource: LeadsResource.Leads,
            httpMethod: httpConstants_1.HttpMethod.GET,
            queryStringParameters: {
                status: isActive ? "ACTIVE" : "INACTIVE",
            },
            headers: this.getInternetBankingHeaders({
                customerId: lead.customer.id,
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async findPromotionBySKU(sku) {
        const { Items: items } = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
            TableName: this.props.leadsPromotionsTable,
            IndexName: "skuIndex",
            KeyConditionExpression: "#sku = :sku",
            ExpressionAttributeNames: {
                "#sku": "sku",
            },
            ExpressionAttributeValues: {
                ":sku": sku,
            },
        }));
        if (!items || items.length === 0) {
            throw new Error("Not found");
        }
        return items[0];
    }
    async createSale(lead) {
        const payload = {
            resource: LeadsResource.LeadSales,
            httpMethod: httpConstants_1.HttpMethod.POST,
            pathParameters: { leadId: lead.id },
            headers: {
                ...this.getBackOfficeHeaders(),
                [BaseRepository_1.APPLICATION_TYPE_HEADER]: "EMPLOYEE",
            },
            body: JSON.stringify(lead),
        };
        return this.sendLambdaCommand(payload);
    }
    async findExternalLead(lead) {
        const payload = {
            resource: LeadsResource.Leads,
            httpMethod: httpConstants_1.HttpMethod.GET,
            requestContext: { identity: { sourceIp: lead.ip } },
            queryStringParameters: {
                documentType: lead.documentType,
                documentNumber: lead.documentNumber,
                email: lead.email,
                mobile: lead.mobile,
            },
            headers: this.getExternalHeaders(),
        };
        return this.sendLambdaCommand(payload);
    }
    async find(lead) {
        const payload = {
            resource: LeadsResource.LeadById,
            httpMethod: httpConstants_1.HttpMethod.GET,
            pathParameters: { leadId: lead.id },
            headers: this.getInternetBankingHeaders({
                customerId: lead.customer.id,
            }),
        };
        return this.sendLambdaCommand(payload);
    }
    async create(lead) {
        await this.selectRangeByProductType(lead);
        await this.props.dynamoDbClient.send(new lib_dynamodb_1.PutCommand({
            TableName: this.props.leadsTable,
            Item: {
                id: this.getUuid(),
                campaignId: Number(lead.campaignId),
                status: lead.status,
                product: {
                    type: lead.product.type,
                    subType: lead.product.subType,
                },
                documentKey: `${lead.customer?.identityDocument?.type}${lead.customer?.identityDocument?.number}`,
                amount: Number(lead.amount),
                interestRate: Number(lead.interestRate),
                annualNominalRate: lead.annualNominalRate,
                currency: lead.currency,
                type: lead.type,
                expirationDate: lead.expirationDate,
                creationDate: lead.creationDate,
            },
        }));
    }
    async update(lead, searchLead) {
        const result = await this.findByIdentityDocument({
            lead: {
                customer: {
                    identityDocument: {
                        type: lead.customer.identityDocument.type,
                        number: lead.customer.identityDocument.number,
                    },
                },
                amount: searchLead,
                currency: lead.currency,
            },
            headerType: httpConstants_1.HeaderType.Employee,
        });
        if (Object.keys(result.body).length === 0) {
            throw new Error("Nothing to update");
        }
        await Promise.all(result.body.map(async (l) => {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: this.props.leadsTable,
                Key: {
                    documentKey: `${lead?.customer?.identityDocument?.type}${lead?.customer?.identityDocument?.number}`,
                    id: l.id,
                },
                UpdateExpression: "SET #amount = :amount",
                ExpressionAttributeNames: {
                    "#amount": "amount",
                },
                ExpressionAttributeValues: {
                    ":amount": lead.amount,
                },
            }));
        }));
    }
    async updateLeadById(lead) {
        const leads = await this.findByIdentityDocument({
            lead: {
                customer: {
                    identityDocument: {
                        type: lead.customer.identityDocument.type,
                        number: lead.customer.identityDocument.number,
                    },
                },
                amount: lead.amount,
                currency: lead.currency,
            },
            headerType: httpConstants_1.HeaderType.Employee,
        });
        const result = leads.body?.filter((item) => item.id === lead.id);
        if (!lead.id || !result || result.lenght === 0) {
            throw new Error("Nothing to update");
        }
        await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
            TableName: this.props.leadsTable,
            Key: {
                documentKey: `${lead?.customer?.identityDocument?.type}${lead?.customer?.identityDocument?.number}`,
                id: lead.id,
            },
            UpdateExpression: "SET #expirationDate = :expirationDate",
            ExpressionAttributeNames: {
                "#expirationDate": "expirationDate",
            },
            ExpressionAttributeValues: {
                ":expirationDate": lead.expirationDate,
            },
        }));
    }
    async createPromotion(promotion) {
        await this.props.dynamoDbClient.send(new lib_dynamodb_1.PutCommand({
            TableName: this.props.leadsPromotionsTable,
            Item: {
                id: this.getUuid(),
                sku: promotion.sku,
                name: promotion.name,
                amount: promotion.amount,
                interestRate: promotion.interestRate,
                annualNominalRate: promotion.annualNominalRate,
                term: promotion.term,
                startDate: promotion.startDate,
                endDate: promotion.endDate,
                creationDate: promotion.creationDate,
                lastUpdateDate: promotion.lastUpdateDate,
            },
        }));
    }
    async updatePromotion(promotion) {
        try {
            const updateExpression = this.getUpdateExpression(promotion, [
                "name",
                "amount",
                "interestRate",
                "annualNominalRate",
                "term",
                "startDate",
                "endDate",
                "lastUpdateDate",
            ]);
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.UpdateCommand({
                TableName: this.props.leadsPromotionsTable,
                Key: {
                    id: promotion.id,
                },
                ConditionExpression: "attribute_exists(id)",
                ...updateExpression,
            }));
        }
        catch (error) {
            throw new Error(error);
        }
    }
    async deleteByIdentityDocument(lead) {
        const response = await this.findAllByIdentityDocument({
            customer: {
                identityDocument: {
                    type: lead.customer.identityDocument.type,
                    number: lead.customer.identityDocument.number,
                },
            },
        });
        if (Object.keys(response).length === 0) {
            throw new Error("Nothing to delete");
        }
        await Promise.all(response.map(async (item) => {
            await this.props.dynamoDbClient.send(new lib_dynamodb_1.DeleteCommand({
                TableName: this.props.leadsTable,
                Key: {
                    documentKey: `${lead.customer.identityDocument.type}${lead.customer.identityDocument.number}`,
                    id: item.id,
                },
            }));
        }));
    }
    unmarshalLead(item) {
        return {
            id: item.id,
            campaignId: item.campaignId,
            product: {
                type: item.product?.type,
                subType: item.product?.subType,
            },
            customer: {
                id: item.customerId,
            },
            interestRate: item.interestRate,
            annualNominalRate: item.annualNominalRate,
            amount: item.amount,
            currency: item.currency,
            creationDate: item.creationDate,
            expirationDate: item.expirationDate,
            status: item.status,
            type: item.type,
        };
    }
    async findAllByIdentityDocument(lead) {
        const { Items: items } = await this.props.dynamoDbClient.send(new lib_dynamodb_1.QueryCommand({
            TableName: this.props.leadsTable,
            KeyConditionExpression: "#documentKey = :documentKey",
            ExpressionAttributeNames: {
                "#documentKey": "documentKey",
            },
            ExpressionAttributeValues: {
                ":documentKey": `${lead.customer.identityDocument.type}${lead.customer.identityDocument.number}`,
            },
        }));
        if (!items || items.length === 0) {
            throw new Error("Not found");
        }
        return items.map((item) => this.unmarshalLead(item));
    }
    selectRangeByProductType(lead) {
        switch (lead.product.subType) {
            case "BNPL":
                if (lead.amount > 10000 || lead.amount < 200) {
                    throw new Error("Amount is out of range");
                }
                break;
            case "LD":
                if (lead.amount > 15000 || lead.amount < 500) {
                    throw new Error("Amount is out of range");
                }
                break;
            default:
                throw new Error(`Subproduct ${lead.product.subType} is not supported`);
        }
    }
}
exports.LeadsRepository = LeadsRepository;
//# sourceMappingURL=LeadsRepository.js.map