"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeadsRequests = void 0;
const BaseRequest_1 = require("./BaseRequest");
const httpConstants_1 = require("../../assets/httpConstants");
class LeadsRequests extends BaseRequest_1.BaseRequests {
    props;
    table;
    customerId;
    leadsRepository;
    customerResponse;
    constructor(props, shouldPrintRequest) {
        super(shouldPrintRequest);
        this.props = props;
        this.table = props.source.table;
        this.customerId = props.source.customer.id;
        this.leadsRepository = props.repositories.repository;
        this.customerResponse = props.source.customer.response;
    }
    async create() {
        const createPromises = this.table.hashes().map(async (row) => {
            const buildRequest = this.buildCreateLead(row);
            await this.printRequest(buildRequest);
            return this.leadsRepository.create(buildRequest);
        });
        return this.execPromiseAll(createPromises);
    }
    async findByIdentityDocument(props) {
        const buildRequest = this.buildFindByIdentityDocument(props);
        await this.printRequest(buildRequest);
        return this.leadsRepository.findByIdentityDocument({
            lead: buildRequest,
            headerType: httpConstants_1.HeaderType.Employee,
            isActive: props.status === "ACTIVE",
        });
    }
    async deleteAllLeads() {
        const deletePromises = this.table.hashes().map(async (row) => {
            const buildRequest = this.buildDeleteAllLeads(row);
            await this.printRequest(buildRequest);
            return this.leadsRepository.deleteByIdentityDocument(buildRequest);
        });
        try {
            return await this.execPromiseAll(deletePromises);
        }
        catch (err) {
            if (err.message !== "Not found") {
                throw new Error(err);
            }
            return null;
        }
    }
    async find(leadId) {
        return this.leadsRepository.find({
            id: leadId,
            customer: {
                id: this.customerResponse.body.id,
                identityDocument: {
                    type: this.customerResponse.body.identityDocument.type,
                    number: this.customerResponse.body.identityDocument.number,
                },
            },
        });
    }
    async createSale(leadId) {
        const salePromises = this.table.hashes().map(async (row) => {
            const buildRequest = this.buildSale(row, leadId);
            await this.printRequest(buildRequest);
            return this.leadsRepository.createSale(buildRequest);
        });
        return this.execPromiseAll(salePromises);
    }
    async findLeadByStatus(status) {
        const buildRequest = this.buildFindLeadByStatus();
        await this.printRequest(buildRequest);
        const request = await this.leadsRepository.findByCustomerId(buildRequest, status.includes("Active"));
        return request;
    }
    async findExternalLead(props) {
        const response = await this.leadsRepository.findExternalLead(props);
        return response;
    }
    buildFindLeadByStatus() {
        return {
            customer: {
                id: this.customerResponse.body.id,
                identityDocument: {
                    type: this.customerResponse.body.identityDocument.type,
                    number: this.customerResponse.body.identityDocument.number,
                },
            },
        };
    }
    buildSale(row, leadId) {
        return {
            id: leadId,
            customer: { id: this.customerId },
            term: parseInt(row.term, 10),
            currency: row.currency,
            amount: parseFloat(row.amount),
            paymentDay: parseInt(row.paymentDay, 10),
            metadata: {
                "external.id": row.loanExternalId,
                "external.branch": row.branch,
                "external.seller": row.seller,
            },
        };
    }
    buildDeleteAllLeads(row) {
        return {
            customer: {
                identityDocument: {
                    type: row.documentType,
                    number: row.documentNumber,
                },
            },
        };
    }
    buildFindByIdentityDocument(props) {
        return {
            customer: {
                identityDocument: {
                    type: props.documentType,
                    number: props.documentNumber,
                },
            },
            amount: Number(props.amount),
            currency: props.currency,
            status: props.status,
        };
    }
    buildCreateLead(row) {
        return {
            campaignId: row.capaingnId,
            annualNominalRate: row.annualNominalRate,
            product: {
                subType: row.subType,
                type: row.type,
            },
            customer: {
                identityDocument: {
                    type: row.documentType,
                    number: row.documentNumber,
                },
            },
            amount: Number(row.amount),
            interestRate: row.interestRate,
            currency: row.currency,
            expirationDate: Number(row.expirationDate) * 86400000 + Date.now(),
            creationDate: Number(row.creationDate.includes("today") ? Date.now() : undefined),
            status: row.status,
        };
    }
}
exports.LeadsRequests = LeadsRequests;
//# sourceMappingURL=LeadsRequest.js.map