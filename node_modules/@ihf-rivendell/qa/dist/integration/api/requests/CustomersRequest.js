"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomerRequests = void 0;
const Validators_1 = require("../../../utils/helpers/Validators");
const BaseRequest_1 = require("./BaseRequest");
class CustomerRequests extends BaseRequest_1.BaseRequests {
    props;
    table;
    types;
    customersRepository;
    customerId;
    constructor(props, shouldPrintRequest) {
        super(shouldPrintRequest);
        this.props = props;
        this.table = props.source.table;
        this.types = props.source.customer.update.types;
        this.customersRepository = props.repositories.repository;
        this.customerId = props.source.customer.id;
    }
    async updateCustomer() {
        const updatePromises = this.table.hashes().map(async (row) => {
            const buildRequest = this.buildUpdateCustomerRequest(row);
            await this.printRequest(buildRequest);
            return this.customersRepository.update(this.customerId, buildRequest);
        });
        return this.execPromiseAll(updatePromises);
    }
    async updatePersonalInfo() {
        const updatePromises = this.table.hashes().map(async (row) => {
            const buildRequest = this.buildUpdatePersonalInfoRequest(row);
            await this.printRequest(buildRequest);
            return this.customersRepository.update(this.customerId, buildRequest);
        });
        return this.execPromiseAll(updatePromises);
    }
    async createCustomerCognito(customerId) {
        const createCustomerPromises = this.buildCreateCustomerCognitoPromises(customerId);
        const createCustomerResponses = await Promise.all(createCustomerPromises);
        return createCustomerResponses[0];
    }
    async createCustomerDynamo() {
        const createCustomerPromises = this.buildCreateCustomerDynamoPromises();
        const createCustomerResponses = await Promise.all(createCustomerPromises);
        return createCustomerResponses[0];
    }
    async createCustomers() {
        const isRegisteredResult = await Promise.all(this.isRegisteredDynamo());
        const isRegisteredId = isRegisteredResult[0]?.body?.id;
        const customerIdDynamo = isRegisteredId || (await this.createCustomerDynamo()).body.id;
        const createdCustomerCognito = await this.createCustomerCognito(customerIdDynamo);
        this.haveCustomerId(createdCustomerCognito);
        const { body: { id: customerId }, } = createdCustomerCognito;
        const customer = await this.customersRepository.findById(customerId);
        return {
            customerId: customer?.body.id,
            mobile: customer?.body.mobile,
            customer,
        };
    }
    async changeStatusToOnboarding(customerId) {
        const changeStatusToOnboardingPromises = await Promise.all(this.buildChangeStatusToOnboarding(customerId));
        return changeStatusToOnboardingPromises[0];
    }
    async deleteByIdentityDocument() {
        try {
            await Promise.all(this.buildDeleteByIdentityDocument());
            return true;
        }
        catch (err) {
            return [];
        }
    }
    async deleteCustomer() {
        const deletePromises = this.table.hashes().map(async (row) => {
            let success = true;
            try {
                await this.customersRepository.deleteByIdentityDocument(row.identityDocumentType, row.identityDocumentNumber);
            }
            catch (err) {
                if (!err.message.includes("Nothing to delete")) {
                    throw err;
                }
                success = true;
            }
            try {
                await this.customersRepository.deleteByMobile(row.mobile);
            }
            catch (err) {
                if (!err.message.includes("User not found")) {
                    throw err;
                }
                success = true;
            }
            return success;
        });
        const [response] = await Promise.all(deletePromises);
        return response;
    }
    async findCustomer(isExtended) {
        const request = this.customersRepository.findById(this.customerId, {
            extended: isExtended && isExtended.includes("extended"),
        });
        await this.printRequest(request);
        return request;
    }
    async findLocations() {
        const request = this.customersRepository.find("/locations");
        await this.printRequest(request);
        return request;
    }
    async changePassword() {
        await Promise.all(this.table?.hashes().map(async (row) => {
            const buildRequest = {
                mobile: row.mobile,
                password: row.new_password,
            };
            await this.printRequest(buildRequest);
            return this.customersRepository.changePassword(row.mobile, row.new_password);
        }) || []);
    }
    async generateAuth() {
        const authPromises = this.table?.hashes().map(async (row) => {
            const buildRequest = {
                mobile: row.mobile,
                password: row.password,
            };
            await this.printRequest(buildRequest);
            return this.customersRepository.initiateAuth(row.mobile, row.password);
        }) || [];
        return this.execPromiseAll(authPromises);
    }
    async findByMobile(mobile) {
        return this.customersRepository.findByMobile(mobile);
    }
    async findByIdentityDocument() {
        const findByIdentityDocumentPromises = this.table
            .hashes()
            .map((row) => this.customersRepository.findByIdentityDocument(row.identityDocumentType, row.identityDocumentNumber));
        return this.execPromiseAll(findByIdentityDocumentPromises);
    }
    buildUpdateCustomerRequest(row) {
        let addressJson;
        if (this.shouldIncludeAddress()) {
            addressJson = {
                line: row.line,
                type: row.type,
                number: row.number,
                apartment: row.apartment,
                urbanization: row.urbanization,
                location: {
                    level1: row.level1,
                    level2: row.level2,
                    level3: row.level3,
                },
            };
        }
        return {
            name: row.name,
            middleName: row.middleName,
            civilStatus: row.civilStatus,
            birthdate: row.birthdate,
            email: row.email,
            acceptedTermsAndConditions: row.acceptedTermsAndConditions,
            address: addressJson,
            employment: this.buildEmploymentRequest(row),
        };
    }
    buildDeleteByIdentityDocument() {
        return this.table
            .hashes()
            .map((row) => this.customersRepository.deleteByIdentityDocument(row.identityDocumentType, row.identityDocumentNumber));
    }
    isRegisteredReniec() {
        return this.table
            ?.hashes()
            .map((row) => this.customersRepository.searchReniecCustomer(row.identityDocumentType, row.identityDocumentNumber));
    }
    isRegisteredDynamo() {
        return this.table
            ?.hashes()
            .map((row) => this.customersRepository.findByIdentityDocument(row.identityDocumentType, row.identityDocumentNumber));
    }
    shouldIncludeAddress() {
        return (this.types?.includes("employment") || this.types?.includes("address"));
    }
    buildEmploymentRequest(row) {
        if (!this.types?.includes("employment")) {
            return undefined;
        }
        return {
            type: row.type_employment,
            sector: row.sector,
            employer: {
                name: row.employer,
            },
            ocupation: row.ocupation,
            income: {
                currency: row.currency,
                range: row.range,
            },
        };
    }
    buildUpdatePersonalInfoRequest(row) {
        return {
            name: row.name,
            middleName: row.middleName,
            civilStatus: row.civilStatus,
            bithdate: row.bithdate,
            email: row.email,
            acceptedTermsAndConditions: row.acceptedTermsAndConditions === "true",
            motherLastName: row.motherLastName,
        };
    }
    buildChangeStatusToOnboarding(customerId) {
        return (this.table?.hashes().map((row) => {
            const timestamp = this.getTimestamp(row.birthdate);
            const buildRequest = {
                civilStatus: row.civilStatus,
                birthdate: Number(timestamp),
                middleName: row.middleName,
                acceptedTermsAndConditions: row.acceptedTermsAndConditions,
            };
            this.printRequest(buildRequest);
            return this.customersRepository?.update(customerId, buildRequest);
        }) || []);
    }
    buildCreateCustomerCognitoPromises(customerId) {
        return (this.table?.hashes().map((row) => {
            const buildRequest = {
                email: row.email,
                mobile: row.mobile,
                name: row.name,
                status: row.status,
            };
            if (row.additionalPurposes === "true") {
                buildRequest.additionalPurposes = true;
            }
            if (row.acceptedTermsAndConditions) {
                buildRequest.acceptedTermsAndConditions = true;
            }
            if (row.civilStatus) {
                buildRequest.civilStatus = row.civilStatus;
            }
            this.printRequest(buildRequest);
            return this.customersRepository?.sendInvitation(customerId, buildRequest);
        }) || []);
    }
    buildCreateCustomerDynamoPromises() {
        return (this.table?.hashes().map((row) => {
            const buildRequest = {
                name: row.name,
                lastName: row.lastName,
                motherLastName: row.motherLastName,
                identityDocument: {
                    type: row.identityDocumentType,
                    number: row.identityDocumentNumber,
                },
            };
            this.printRequest(buildRequest);
            return this.customersRepository?.createCustomer(buildRequest);
        }) || []);
    }
    haveCustomerId(createdCustomerResponse) {
        if (createdCustomerResponse.statusCode !== 200) {
            throw new Error(JSON.stringify(createdCustomerResponse));
        }
    }
    getTimestamp(birthdate) {
        const extractedAge = (0, Validators_1.extractAgeFromInput)(birthdate);
        if (extractedAge !== null) {
            const timestamp = (0, Validators_1.getTimestampForAge)(extractedAge);
            return timestamp;
        }
        return birthdate;
    }
}
exports.CustomerRequests = CustomerRequests;
//# sourceMappingURL=CustomersRequest.js.map